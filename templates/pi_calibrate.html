{% extends "base.html" %}

{% block title %}Calibration - FarmBOT{% endblock %}

{% block content %}
    <style>
        .camera-view {
            width: 100%;
        height: 500px;
            background-color: #000;
            position: relative;
            border-radius: 5px;
            overflow: hidden;
            cursor: crosshair;
        }

        .camera-view img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .calibration-point {
            position: absolute;
        width: 16px;
        height: 16px;
            background-color: #ff0000;
        border: 3px solid #fff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        z-index: 10;
        box-shadow: 0 0 10px rgba(255, 0, 0, 0.8);
        }

        .point-label {
            position: absolute;
            color: #fff;
        background-color: rgba(0, 0, 0, 0.8);
        padding: 4px 8px;
        border-radius: 4px;
            font-size: 12px;
        font-weight: bold;
            transform: translate(-50%, -200%);
            pointer-events: none;
        z-index: 11;
        white-space: nowrap;
    }

    .point-label::after {
        content: '';
        position: absolute;
        top: 100%;
        left: 50%;
        transform: translateX(-50%);
        border: 5px solid transparent;
        border-top-color: rgba(0, 0, 0, 0.8);
    }

    .calibration-status {
        padding: 10px;
        border-radius: 5px;
        margin-bottom: 15px;
    }

    .status-good {
        background-color: #d4edda;
        color: #155724;
        border: 1px solid #c3e6cb;
    }

    .status-warning {
        background-color: #fff3cd;
        color: #856404;
        border: 1px solid #ffeaa7;
    }

    .status-error {
        background-color: #f8d7da;
        color: #721c24;
        border: 1px solid #f5c6cb;
    }

    .point-card {
        border-left: 4px solid #007bff;
        margin-bottom: 10px;
        transition: transform 0.2s;
    }

    .point-card:hover {
        transform: translateX(5px);
    }

    .accuracy-badge {
        font-size: 0.85rem;
        padding: 5px 10px;
    }

    .test-result {
        padding: 10px;
        margin: 5px 0;
        border-radius: 5px;
        background-color: #f8f9fa;
    }

    .test-result.success {
        background-color: #d4edda;
        border-left: 4px solid #28a745;
    }

    .test-result.error {
        background-color: #f8d7da;
        border-left: 4px solid #dc3545;
        }
    </style>

<div class="row mb-4">
    <div class="col-12">
        <h1 class="mb-0">
            <i class="fas fa-ruler-combined"></i> Camera-to-Arm Calibration
        </h1>
        <p class="text-muted">Calibrate the coordinate mapping between camera pixels and robotic arm positions</p>
            </div>
        </div>

<!-- Calibration Status -->
<div id="calibration-status" class="calibration-status status-warning" style="display: none;">
    <strong><i class="fas fa-info-circle"></i> Status:</strong> <span id="status-text">No calibration loaded</span>
</div>

<!-- Main Content Row -->
        <div class="row">
    <!-- Camera View -->
    <div class="col-lg-8">
                <div class="card mb-4">
                    <div class="card-header bg-dark text-white d-flex justify-content-between align-items-center">
                <h5 class="mb-0"><i class="fas fa-camera"></i> Live Camera Feed</h5>
                <div class="d-flex gap-2 align-items-center">
                    <select class="form-select form-select-sm" id="camera-selector" onchange="switchCamera()" style="width: auto; min-width: 150px;">
                        <option value="">Loading cameras...</option>
                    </select>
                    <button class="btn btn-sm btn-outline-light" onclick="refreshCameraList()" title="Refresh Camera List">
                        <i class="fas fa-sync-alt"></i>
                    </button>
                    <button id="btnStartCamera" class="btn btn-sm btn-success" onclick="startCameraFeed()" title="Start Camera">
                        <i class="fas fa-play"></i> Start
                    </button>
                    <button id="btnStopCamera" class="btn btn-sm btn-danger" onclick="stopCameraFeed()" title="Stop Camera" style="display: none;">
                        <i class="fas fa-stop"></i> Stop
                    </button>
                    <button class="btn btn-sm btn-outline-light" onclick="refreshCamera()" title="Refresh Camera">
                        <i class="fas fa-redo"></i>
                    </button>
                    <button class="btn btn-sm btn-outline-light" onclick="toggleFullscreen()" title="Fullscreen">
                        <i class="fas fa-expand"></i>
                    </button>
                </div>
                    </div>
                    <div class="card-body p-0">
                        <div class="camera-view" id="camera-container" style="position: relative; background: #000; min-height: 480px; display: flex; align-items: center; justify-content: center;">
                    <img id="camera-feed" alt="Camera Feed" style="display: none; width: 100%; height: auto;"
                         onerror="this.src='data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'640\' height=\'480\'%3E%3Crect fill=\'%23333\' width=\'640\' height=\'480\'/%3E%3Ctext fill=\'%23fff\' x=\'50%25\' y=\'50%25\' text-anchor=\'middle\' dy=\'.3em\'%3ECamera not available%3C/text%3E%3C/svg%3E'">
                    <div id="camera-placeholder" style="color: #fff; text-align: center; position: absolute;">
                        <i class="fas fa-camera" style="font-size: 3rem; opacity: 0.5;"></i>
                        <p>Click "Start" to begin camera feed</p>
                    </div>
                        </div>
                    </div>
                    <div class="card-footer">
                <small class="text-muted">
                    <i class="fas fa-mouse-pointer"></i> Click on the camera feed to add calibration points
                    <br>
                    <i class="fas fa-info-circle"></i> <strong>Tip:</strong> Use the dropdown above to switch to your USB ArduCam (usually Camera 1 or higher)
                </small>
            </div>
        </div>

        <!-- Test Calibration Section -->
        <div class="card mb-4" id="test-section" style="display: none;">
            <div class="card-header bg-info text-white">
                <h5 class="mb-0"><i class="fas fa-vial"></i> Test Calibration</h5>
            </div>
            <div class="card-body">
                <p class="text-muted">Click on a point in the camera feed to test the calibration accuracy.</p>
                <div id="test-results"></div>
                <button class="btn btn-outline-secondary btn-sm" onclick="clearTestResults()">
                    <i class="fas fa-trash"></i> Clear Results
                </button>
                    </div>
                </div>
            </div>

    <!-- Control Panel -->
    <div class="col-lg-4">
        <!-- Calibration Points List -->
                <div class="card mb-3">
            <div class="card-header bg-primary text-white d-flex justify-content-between align-items-center">
                <h5 class="mb-0"><i class="fas fa-map-marker-alt"></i> Calibration Points</h5>
                <span class="badge bg-light text-dark" id="point-count">0</span>
                    </div>
            <div class="card-body" style="max-height: 300px; overflow-y: auto;">
                <div id="points-list">
                    <p class="text-muted small text-center">No points added yet. Click on the camera feed to start.</p>
                        </div>
                        
                <!-- Point Input Form -->
                <div id="point-input-form" style="display: none;" class="mt-3 border-top pt-3">
                            <h6>Point <span id="current-point-num"></span></h6>
                            <div class="mb-2">
                        <label class="form-label small"><strong>Pixel Coordinates:</strong></label>
                        <div class="input-group input-group-sm">
                            <span class="input-group-text">X</span>
                            <input type="text" class="form-control" id="pixel-x" readonly>
                            <span class="input-group-text">Y</span>
                            <input type="text" class="form-control" id="pixel-y" readonly>
                        </div>
                            </div>
                            <div class="mb-2">
                        <label class="form-label small"><strong>Real World X (mm)</strong></label>
                        <input type="number" class="form-control form-control-sm" id="world-x" step="0.1" placeholder="Enter X coordinate">
                            </div>
                            <div class="mb-2">
                        <label class="form-label small"><strong>Real World Y (mm)</strong></label>
                        <input type="number" class="form-control form-control-sm" id="world-y" step="0.1" placeholder="Enter Y coordinate">
                            </div>
                    <div class="d-grid gap-2">
                        <button class="btn btn-sm btn-primary" onclick="confirmPoint()">
                                <i class="fas fa-check"></i> Confirm Point
                            </button>
                        <button class="btn btn-sm btn-outline-secondary" onclick="cancelPoint()">
                            <i class="fas fa-times"></i> Cancel
                        </button>
                    </div>
                </div>
                    </div>
                </div>

        <!-- Actions -->
        <div class="card mb-3">
                    <div class="card-header bg-warning text-dark">
                <h5 class="mb-0"><i class="fas fa-cogs"></i> Actions</h5>
                    </div>
                    <div class="card-body">
                        <div class="d-grid gap-2">
                    <button class="btn btn-success" onclick="runCalibration()" id="calibrate-btn" disabled>
                        <i class="fas fa-calculator"></i> Calculate & Save Calibration
                    </button>
                    <button class="btn btn-outline-primary" onclick="testCalibration()" id="test-btn" disabled>
                        <i class="fas fa-vial"></i> Test Calibration
                    </button>
                    <button class="btn btn-outline-info" onclick="loadCalibration()">
                        <i class="fas fa-upload"></i> Load Existing Calibration
                    </button>
                            <button class="btn btn-outline-danger" onclick="clearLastPoint()" id="clear-btn" disabled>
                        <i class="fas fa-undo"></i> Remove Last Point
                            </button>
                            <button class="btn btn-outline-secondary" onclick="resetCalibration()">
                        <i class="fas fa-trash"></i> Reset All Points
                            </button>
                        </div>
                        <div class="mt-3">
                    <small class="text-muted">
                        <i class="fas fa-info-circle"></i> Need at least 4 points for calibration. More points = better accuracy.
                    </small>
                </div>
            </div>
        </div>

        <!-- Arm Movement Controls -->
        <div class="card mb-3">
            <div class="card-header bg-success text-white">
                <h5 class="mb-0"><i class="fas fa-hand-paper"></i> Arm Movement</h5>
            </div>
            <div class="card-body">
                <p class="text-muted small">Move the arm to a known position, then click on that position in the camera feed.</p>
                <div class="mb-2">
                    <label class="form-label small">Move to Position (mm)</label>
                    <div class="input-group input-group-sm mb-2">
                        <span class="input-group-text">X</span>
                        <input type="number" class="form-control" id="move-x" step="1" placeholder="X (mm)">
                        </div>
                    <div class="input-group input-group-sm">
                        <span class="input-group-text">Y</span>
                        <input type="number" class="form-control" id="move-y" step="1" placeholder="Y (mm)">
                    </div>
                </div>
                <div class="d-grid gap-2">
                    <button class="btn btn-sm btn-success" onclick="moveArmToPosition()">
                        <i class="fas fa-arrow-right"></i> Move Arm
                    </button>
                    <button class="btn btn-sm btn-outline-secondary" onclick="homeArm()">
                        <i class="fas fa-home"></i> Home Arm
                    </button>
                </div>
            </div>
        </div>

        <!-- Calibration Info -->
        <div class="card">
            <div class="card-header bg-secondary text-white">
                <h5 class="mb-0"><i class="fas fa-info-circle"></i> Calibration Info</h5>
            </div>
            <div class="card-body">
                <div id="calibration-info">
                    <p class="text-muted small">No calibration data available.</p>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        let calibrationPoints = [];
        let pendingPoint = null;
    let calibrationData = null;
    let testMode = false;

    // Initialize camera feed refresh
    let cameraRefreshInterval = null;
    let isPageVisible = true;
    
    function refreshCamera() {
        // Only refresh if page is visible
        if (!isPageVisible) return;
        
        const img = document.getElementById('camera-feed');
        if (img && img.complete) {
            const src = img.src.split('?')[0];
            img.src = src + '?t=' + new Date().getTime();
        }
    }

    // Use proper video streaming instead of polling
    // Auto-refresh camera every 500ms (2 FPS is enough for calibration)
    // This reduces network load significantly
    function startCameraRefresh() {
        if (cameraRefreshInterval) {
            clearInterval(cameraRefreshInterval);
        }
        cameraRefreshInterval = setInterval(refreshCamera, 500);
    }
    
    function stopCameraRefresh() {
        if (cameraRefreshInterval) {
            clearInterval(cameraRefreshInterval);
            cameraRefreshInterval = null;
        }
    }
    
    // Pause refresh when page is not visible (saves resources)
    document.addEventListener('visibilitychange', function() {
        isPageVisible = !document.hidden;
        if (isPageVisible) {
            startCameraRefresh();
        } else {
            stopCameraRefresh();
        }
    });
    
    // Start refresh on page load
    startCameraRefresh();

    // Fullscreen toggle
    function toggleFullscreen() {
        const container = document.getElementById('camera-container');
        if (!document.fullscreenElement) {
            container.requestFullscreen().catch(err => {
                console.error('Error attempting to enable fullscreen:', err);
            });
        } else {
            document.exitFullscreen();
        }
    }

    // Handle camera click
        document.getElementById('camera-container').addEventListener('click', function(e) {
        console.log('Camera clicked, testMode:', testMode, 'calibrationData:', !!calibrationData);
        
        if (testMode && calibrationData) {
            console.log('Handling test click');
            handleTestClick(e);
            return;
        }
        
        console.log('Handling normal calibration point click');

        const img = document.getElementById('camera-feed');
        const rect = img.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Convert to image coordinates
        const imgWidth = img.naturalWidth || 640;
        const imgHeight = img.naturalHeight || 480;
            const scaleX = imgWidth / rect.width;
            const scaleY = imgHeight / rect.height;
            
            const pixelX = Math.round(x * scaleX);
            const pixelY = Math.round(y * scaleY);
            
            // Show input form
            pendingPoint = {pixel: [pixelX, pixelY], displayX: x, displayY: y};
        document.getElementById('pixel-x').value = pixelX;
        document.getElementById('pixel-y').value = pixelY;
            document.getElementById('current-point-num').textContent = calibrationPoints.length + 1;
            document.getElementById('point-input-form').style.display = 'block';
            document.getElementById('world-x').value = '';
            document.getElementById('world-y').value = '';
            document.getElementById('world-x').focus();
        });

        function confirmPoint() {
            const worldX = parseFloat(document.getElementById('world-x').value);
            const worldY = parseFloat(document.getElementById('world-y').value);
            
            if (isNaN(worldX) || isNaN(worldY)) {
                alert('Please enter valid coordinates');
                return;
            }
            
            pendingPoint.world = [worldX, worldY];
            calibrationPoints.push(pendingPoint);
            
            // Add visual marker
        addPointMarker(pendingPoint, calibrationPoints.length);
            
            updatePointsList();
            document.getElementById('point-input-form').style.display = 'none';
            pendingPoint = null;
            
            // Enable buttons
            document.getElementById('clear-btn').disabled = false;
            if (calibrationPoints.length >= 4) {
                document.getElementById('calibrate-btn').disabled = false;
            }
        }

    function cancelPoint() {
        pendingPoint = null;
        document.getElementById('point-input-form').style.display = 'none';
    }

    function addPointMarker(point, index) {
        const container = document.getElementById('camera-container');
        
        const marker = document.createElement('div');
        marker.className = 'calibration-point';
        marker.style.left = point.displayX + 'px';
        marker.style.top = point.displayY + 'px';
        marker.dataset.index = index - 1;
        
        const label = document.createElement('div');
        label.className = 'point-label';
        label.textContent = `P${index}`;
        label.style.left = point.displayX + 'px';
        label.style.top = point.displayY + 'px';
        
        container.appendChild(marker);
        container.appendChild(label);
    }

        function updatePointsList() {
            const list = document.getElementById('points-list');
        const count = document.getElementById('point-count');
        count.textContent = calibrationPoints.length;
        
            if (calibrationPoints.length === 0) {
            list.innerHTML = '<p class="text-muted small text-center">No points added yet. Click on the camera feed to start.</p>';
                // Disable buttons when no points
                document.getElementById('clear-btn').disabled = true;
                document.getElementById('calibrate-btn').disabled = true;
                return;
            }
            
        let html = '';
            calibrationPoints.forEach((p, i) => {
            html += `
                <div class="point-card card mb-2">
                    <div class="card-body py-2 px-3">
                        <div class="d-flex justify-content-between align-items-center">
                            <div>
                                <strong>Point ${i+1}</strong><br>
                                <small class="text-muted">
                                    Pixel: (${p.pixel[0]}, ${p.pixel[1]})<br>
                                    World: (${p.world[0].toFixed(1)}, ${p.world[1].toFixed(1)}) mm
                                </small>
                            </div>
                            <button class="btn btn-sm btn-outline-danger" onclick="removePoint(${i})" title="Remove point">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                    </div>
                </div>
            `;
        });
            list.innerHTML = html;
            
            // Update button states based on point count
            document.getElementById('clear-btn').disabled = calibrationPoints.length === 0;
            document.getElementById('calibrate-btn').disabled = calibrationPoints.length < 4;
            
            console.log(`updatePointsList: ${calibrationPoints.length} points, calibrate-btn disabled: ${document.getElementById('calibrate-btn').disabled}`);
        }

    function removePoint(index) {
        calibrationPoints.splice(index, 1);
                const container = document.getElementById('camera-container');
                const markers = container.querySelectorAll('.calibration-point, .point-label');
        // Remove all markers and re-add them
        markers.forEach(m => m.remove());
        calibrationPoints.forEach((p, i) => {
            addPointMarker({...p, displayX: p.displayX, displayY: p.displayY}, i + 1);
        });
                updatePointsList();
                
                if (calibrationPoints.length === 0) {
                    document.getElementById('clear-btn').disabled = true;
                }
                if (calibrationPoints.length < 4) {
                    document.getElementById('calibrate-btn').disabled = true;
                }
    }

    function clearLastPoint() {
        if (calibrationPoints.length > 0) {
            removePoint(calibrationPoints.length - 1);
            }
        }

        function resetCalibration() {
            if (confirm('Are you sure you want to reset all calibration points?')) {
                calibrationPoints = [];
                const markers = document.querySelectorAll('.calibration-point, .point-label');
                markers.forEach(m => m.remove());
                updatePointsList();
                document.getElementById('clear-btn').disabled = true;
                document.getElementById('calibrate-btn').disabled = true;
            document.getElementById('test-btn').disabled = true;
                document.getElementById('point-input-form').style.display = 'none';
            testMode = false;
            document.getElementById('test-section').style.display = 'none';
        }
        }

        async function runCalibration() {
            console.log('runCalibration called, points:', calibrationPoints.length);
            console.log('calibrationPoints:', calibrationPoints);
            
            // Double-check button state
            const btn = document.getElementById('calibrate-btn');
            console.log('Button disabled state:', btn.disabled);
            console.log('Button element:', btn);
            
            if (calibrationPoints.length < 4) {
                alert('Need at least 4 points for calibration. You have ' + calibrationPoints.length + ' points.');
                return;
            }
            
            // Force enable button (in case it's stuck disabled)
            btn.disabled = false;
            
            // Disable button during processing
            btn.disabled = true;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Calculating...';
            
            try {
                console.log('Sending calibration request with', calibrationPoints.length, 'points');
                console.log('Calibration points data:', JSON.stringify(calibrationPoints, null, 2));
                
                // Create AbortController for timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
                
                const response = await fetch('/api/calibration/calculate', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({points: calibrationPoints}),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                console.log('Response status:', response.status);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Server error: ${response.status} - ${errorText}`);
                }
                
                const result = await response.json();
                console.log('Response result:', result);
                
                if (result.success) {
                    calibrationData = result.data;
                    updateCalibrationInfo(result.data);
                    showStatus('Calibration calculated successfully!', 'good');
                    
                    // Save calibration
                    console.log('Saving calibration...');
                    await saveCalibration();
                    
                    // Enable test button
                    document.getElementById('test-btn').disabled = false;
                    btn.innerHTML = '<i class="fas fa-calculator"></i> Calculate & Save Calibration';
                    btn.disabled = false;
                } else {
                    showStatus('Calibration failed: ' + result.message, 'error');
                    btn.innerHTML = '<i class="fas fa-calculator"></i> Calculate & Save Calibration';
                    btn.disabled = false;
                }
            } catch (error) {
                console.error('Error calculating calibration:', error);
                let errorMessage = 'Error calculating calibration: ';
                
                if (error.name === 'AbortError') {
                    errorMessage += 'Request timed out after 30 seconds. The server may be busy or unresponsive.';
                } else if (error.message) {
                    errorMessage += error.message;
                } else {
                    errorMessage += 'Unknown error occurred. Check console for details.';
                }
                
                showStatus(errorMessage, 'error');
                btn.innerHTML = '<i class="fas fa-calculator"></i> Calculate & Save Calibration';
                btn.disabled = false;
            }
        }

    async function saveCalibration() {
        try {
            console.log('saveCalibration called');
            if (!calibrationData) {
                console.error('No calibration data to save');
                showStatus('Error: No calibration data to save. Calculate calibration first.', 'error');
                return;
            }
            
            const response = await fetch('/api/calibration/save', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    points: calibrationPoints,
                    calibration: calibrationData
                })
            });
            
            console.log('Save response status:', response.status);
            const result = await response.json();
            console.log('Save response result:', result);
            
            if (result.success) {
                showStatus('Calibration saved successfully!', 'good');
            } else {
                showStatus('Error saving calibration: ' + result.message, 'error');
            }
        } catch (error) {
            console.error('Error saving calibration:', error);
            showStatus('Error saving calibration: ' + error.message, 'error');
        }
    }

    async function loadCalibration() {
        try {
            console.log('Loading calibration...');
            const response = await fetch('/api/calibration/load');
            const result = await response.json();
            
            console.log('Load calibration response:', result);
            
            if (result.success && result.data) {
                // Handle different data structures
                if (result.data.calibration) {
                    calibrationData = result.data.calibration;
                } else if (result.data.matrix) {
                    // If matrix is at top level, create calibration object
                    calibrationData = {
                        matrix: result.data.matrix,
                        point_count: result.data.point_count || 0
                    };
                }
                
                if (result.data.points && result.data.points.length > 0) {
                    calibrationPoints = result.data.points;
                    
                    // Calculate displayX and displayY for each point if missing
                    const img = document.getElementById('camera-feed');
                    if (img) {
                        const rect = img.getBoundingClientRect();
                        const imgWidth = img.naturalWidth || 640;
                        const imgHeight = img.naturalHeight || 480;
                        const scaleX = rect.width / imgWidth;
                        const scaleY = rect.height / imgHeight;
                        
                        calibrationPoints.forEach((p, i) => {
                            if (!p.displayX || !p.displayY) {
                                // Calculate display coordinates from pixel coordinates
                                // Validate pixel property exists and is a valid array
                                if (p.pixel && Array.isArray(p.pixel) && p.pixel.length >= 2) {
                                p.displayX = p.pixel[0] * scaleX;
                                p.displayY = p.pixel[1] * scaleY;
                                } else {
                                    console.warn(`Point ${i} missing valid pixel coordinates, skipping display calculation`);
                                }
                            }
                        });
                    }
                    
                    // Re-add visual markers
                    const container = document.getElementById('camera-container');
                    const markers = container.querySelectorAll('.calibration-point, .point-label');
                    markers.forEach(m => m.remove());
                    calibrationPoints.forEach((p, i) => {
                        addPointMarker(p, i + 1);
                    });
                    updatePointsList();
                }
                
                if (calibrationData) {
                    updateCalibrationInfo(calibrationData);
                }
                
                showStatus('Calibration loaded successfully!', 'good');
                document.getElementById('test-btn').disabled = false;
                console.log('Calibration loaded:', calibrationData);
            } else {
                showStatus('No calibration found or error loading: ' + (result.message || 'Unknown error'), 'warning');
                console.warn('Load calibration failed:', result);
            }
        } catch (error) {
            console.error('Error loading calibration:', error);
            showStatus('Error loading calibration: ' + error.message, 'error');
        }
    }

    function updateCalibrationInfo(data) {
        const infoDiv = document.getElementById('calibration-info');
        if (!data) {
            infoDiv.innerHTML = '<p class="text-muted small">No calibration data available.</p>';
            return;
        }
        
        let html = '<div class="small">';
        if (data.accuracy) {
            const accuracyClass = data.accuracy < 5 ? 'success' : (data.accuracy < 10 ? 'warning' : 'danger');
            html += `<p><strong>Accuracy:</strong> <span class="badge bg-${accuracyClass} accuracy-badge">${data.accuracy.toFixed(2)} mm</span></p>`;
        }
        if (data.point_count) {
            html += `<p><strong>Points Used:</strong> ${data.point_count}</p>`;
        }
        if (data.timestamp) {
            html += `<p><strong>Calibrated:</strong> ${new Date(data.timestamp).toLocaleString()}</p>`;
        }
        html += '</div>';
        infoDiv.innerHTML = html;
    }

    function showStatus(message, type) {
        const statusDiv = document.getElementById('calibration-status');
        const statusText = document.getElementById('status-text');
        statusDiv.className = `calibration-status status-${type}`;
        statusText.textContent = message;
        statusDiv.style.display = 'block';
        
        // Auto-hide after 5 seconds for success messages
        if (type === 'good') {
            setTimeout(() => {
                statusDiv.style.display = 'none';
            }, 5000);
        }
    }

    function testCalibration() {
        console.log('testCalibration called');
        console.log('calibrationData:', calibrationData);
        
        if (!calibrationData) {
            alert('Please calculate calibration first');
            return;
        }
        
        testMode = true;
        console.log('Test mode enabled:', testMode);
        document.getElementById('test-section').style.display = 'block';
        showStatus('Test mode active - Click on camera feed to test calibration', 'info');
        console.log('Test section displayed, ready for clicks');
    }

    async function handleTestClick(e) {
        console.log('handleTestClick called', e);
        console.log('testMode:', testMode, 'calibrationData:', calibrationData);
        
        if (!testMode || !calibrationData) {
            console.warn('Test mode not active or no calibration data');
            return;
        }
        
        const img = document.getElementById('camera-feed');
        if (!img) {
            console.error('Camera feed image not found');
            showStatus('Error: Camera feed not found', 'error');
            return;
        }
        
        const rect = img.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        console.log('Click position:', x, y, 'Image rect:', rect);
        
        const imgWidth = img.naturalWidth || 640;
        const imgHeight = img.naturalHeight || 480;
        const scaleX = imgWidth / rect.width;
        const scaleY = imgHeight / rect.height;
        
        const pixelX = Math.round(x * scaleX);
        const pixelY = Math.round(y * scaleY);
        
        console.log('Pixel coordinates:', pixelX, pixelY);
        
        // Add visual marker on camera feed to show where user clicked
        addTestMarker(x, y, pixelX, pixelY);
        
        showStatus('Testing calibration...', 'info');
        
        try {
            const response = await fetch('/api/calibration/test', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({pixel: [pixelX, pixelY]})
            });
            
            console.log('Test response status:', response.status);
            const result = await response.json();
            console.log('Test response result:', result);
            
            if (result.success) {
                const resultsDiv = document.getElementById('test-results');
                if (!resultsDiv) {
                    console.error('test-results div not found');
                    showStatus('Error: Test results container not found', 'error');
                    return;
                }
                
                // Update the marker with results
                updateTestMarker(x, y, result.predicted, result.error);
                
                const resultClass = result.error < 5 ? 'success' : 'warning';
                const resultHtml = `
                    <div class="alert alert-${resultClass} mb-2">
                        <strong>Test Point:</strong> Pixel(${pixelX}, ${pixelY})<br>
                        <strong>Predicted World Coordinates:</strong> (${result.predicted[0].toFixed(1)}, ${result.predicted[1].toFixed(1)}) mm<br>
                        ${result.actual ? `<strong>Actual:</strong> (${result.actual[0].toFixed(1)}, ${result.actual[1].toFixed(1)}) mm<br>` : ''}
                        <strong>Error:</strong> ${result.error.toFixed(2)} mm
                    </div>
                `;
                resultsDiv.innerHTML = resultHtml + resultsDiv.innerHTML;
                showStatus(`Test complete: Pixel(${pixelX}, ${pixelY}) â†’ (${result.predicted[0].toFixed(1)}, ${result.predicted[1].toFixed(1)}) mm`, 'good');
            } else {
                showStatus('Test failed: ' + result.message, 'error');
            }
        } catch (error) {
            console.error('Error testing calibration:', error);
            showStatus('Error testing calibration: ' + error.message, 'error');
        }
    }
    
    function addTestMarker(displayX, displayY, pixelX, pixelY) {
        const container = document.getElementById('camera-container');
        
        // Remove any existing test markers
        const existingMarkers = container.querySelectorAll('.test-marker, .test-label');
        existingMarkers.forEach(m => m.remove());
        
        // Create marker circle
        const marker = document.createElement('div');
        marker.className = 'test-marker';
        marker.style.left = displayX + 'px';
        marker.style.top = displayY + 'px';
        marker.style.position = 'absolute';
        marker.style.width = '20px';
        marker.style.height = '20px';
        marker.style.borderRadius = '50%';
        marker.style.border = '3px solid #00ff00';
        marker.style.backgroundColor = 'rgba(0, 255, 0, 0.3)';
        marker.style.transform = 'translate(-50%, -50%)';
        marker.style.pointerEvents = 'none';
        marker.style.zIndex = '1000';
        
        // Create label
        const label = document.createElement('div');
        label.className = 'test-label';
        label.style.left = (displayX + 15) + 'px';
        label.style.top = (displayY - 15) + 'px';
        label.style.position = 'absolute';
        label.style.backgroundColor = 'rgba(0, 255, 0, 0.9)';
        label.style.color = '#000';
        label.style.padding = '2px 6px';
        label.style.borderRadius = '3px';
        label.style.fontSize = '11px';
        label.style.fontWeight = 'bold';
        label.style.pointerEvents = 'none';
        label.style.zIndex = '1001';
        label.textContent = `P(${pixelX}, ${pixelY})`;
        label.id = 'test-label';
        
        container.appendChild(marker);
        container.appendChild(label);
    }
    
    function updateTestMarker(displayX, displayY, predicted, error) {
        const label = document.getElementById('test-label');
        if (label) {
            const color = error < 5 ? '#00ff00' : (error < 10 ? '#ffaa00' : '#ff0000');
            label.style.backgroundColor = color;
            label.textContent = `(${predicted[0].toFixed(0)}, ${predicted[1].toFixed(0)})mm`;
        }
    }

    function clearTestResults() {
        document.getElementById('test-results').innerHTML = '';
        // Remove test markers from camera feed
        const container = document.getElementById('camera-container');
        const markers = container.querySelectorAll('.test-marker, .test-label');
        markers.forEach(m => m.remove());
    }

    async function moveArmToPosition() {
        const xInput = document.getElementById('move-x');
        const yInput = document.getElementById('move-y');
        
        if (!xInput || !yInput) {
            console.error('Move X or Y input not found');
            showStatus('Error: Move position inputs not found', 'error');
            return;
        }
        
        const x = parseFloat(xInput.value);
        const y = parseFloat(yInput.value);
        
        console.log('moveArmToPosition called with:', x, y);
        
        if (isNaN(x) || isNaN(y)) {
            alert('Please enter valid coordinates (numbers only)');
            return;
        }
        
        // Show loading state
        showStatus(`Moving arm to (${x}, ${y}) mm...`, 'info');
        
        try {
            console.log('Sending move command:', {x, y, z: 50});
            const response = await fetch('/api/arm/move', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({x: x, y: y, z: 50})  // Add default Z height
            });
            
            console.log('Move response status:', response.status);
            const result = await response.json();
            console.log('Move response result:', result);
            
            if (result.success) {
                showStatus(`Arm moving to (${x}, ${y}) mm - ${result.message}`, 'good');
            } else {
                showStatus('Error moving arm: ' + result.message, 'error');
                console.error('Move arm failed:', result);
            }
        } catch (error) {
            console.error('Error moving arm:', error);
            showStatus('Error moving arm: ' + error.message, 'error');
        }
    }

    async function homeArm() {
        try {
            const response = await fetch('/api/arm/home', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'}
            });
            
            const result = await response.json();
            if (result.success) {
                showStatus('Arm homed successfully', 'good');
            } else {
                showStatus('Error homing arm: ' + result.message, 'error');
            }
        } catch (error) {
            showStatus('Error homing arm: ' + error.message, 'error');
        }
    }

    // Camera management
    async function loadCameraList(forceRefresh = false) {
        try {
            const url = forceRefresh ? '/api/camera/list?refresh=true' : '/api/camera/list';
            const response = await fetch(url);
            const result = await response.json();
            
            if (result.success && result.cameras) {
                const selector = document.getElementById('camera-selector');
                selector.innerHTML = '';
                
                if (result.cameras.length === 0) {
                    selector.innerHTML = '<option value="">No cameras found</option>';
                    return;
                }
                
                result.cameras.forEach(camera => {
                    const option = document.createElement('option');
                    option.value = camera.index;
                    const typeLabel = camera.type ? ` [${camera.type}]` : '';
                    option.textContent = `${camera.name}${typeLabel} (${camera.resolution})${camera.current ? ' [Current]' : ''}`;
                    if (camera.current) {
                        option.selected = true;
                    }
                    selector.appendChild(option);
                });
            }
        } catch (error) {
            console.error('Error loading camera list:', error);
            document.getElementById('camera-selector').innerHTML = '<option value="">Error loading cameras</option>';
        }
    }
    
    async function switchCamera() {
        const selector = document.getElementById('camera-selector');
        const cameraIndex = parseInt(selector.value);
        
        if (isNaN(cameraIndex)) {
            return;
        }
        
        try {
            const response = await fetch('/api/camera/switch', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({index: cameraIndex})
            });
            
            const result = await response.json();
            if (result.success) {
                showStatus(`Switched to camera ${cameraIndex}`, 'good');
                // Refresh camera list to update current indicator
                setTimeout(loadCameraList, 500);
                // Refresh camera feed
                refreshCamera();
            } else {
                showStatus('Error switching camera: ' + result.message, 'error');
            }
        } catch (error) {
            showStatus('Error switching camera: ' + error.message, 'error');
        }
    }
    
    function refreshCameraList() {
        loadCameraList(true); // Force refresh to re-detect all cameras
    }
    
    // Auto-detect and prefer USB cameras (usually index 1 or higher)
    async function autoSelectUSBCamera() {
        try {
            const response = await fetch('/api/camera/list');
            const result = await response.json();
            
            if (result.success && result.cameras && result.cameras.length > 1) {
                // Prefer cameras with index > 0 (usually USB cameras)
                // Index 0 is typically the built-in camera
                const usbCameras = result.cameras.filter(c => c.index > 0);
                if (usbCameras.length > 0) {
                    // Switch to first USB camera
                    const usbCamera = usbCameras[0];
                    const switchResponse = await fetch('/api/camera/switch', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({index: usbCamera.index})
                    });
                    
                    const switchResult = await switchResponse.json();
                    if (switchResult.success) {
                        showStatus(`Auto-selected USB camera (index ${usbCamera.index})`, 'good');
                        loadCameraList();
                        refreshCamera();
                    }
                }
            }
        } catch (error) {
            console.error('Error auto-selecting USB camera:', error);
        }
    }

    // Camera feed control
    let isCameraFeedRunning = false;
    
    function startCameraFeed() {
        if (isCameraFeedRunning) return;
        
        const cameraFeed = document.getElementById('camera-feed');
        const placeholder = document.getElementById('camera-placeholder');
        const btnStart = document.getElementById('btnStartCamera');
        const btnStop = document.getElementById('btnStopCamera');
        
        if (cameraFeed && placeholder) {
            placeholder.style.display = 'none';
            cameraFeed.style.display = 'block';
            cameraFeed.src = "/api/camera/feed?" + new Date().getTime();
            isCameraFeedRunning = true;
            
            if (btnStart) btnStart.style.display = 'none';
            if (btnStop) btnStop.style.display = 'inline-block';
        }
    }
    
    function stopCameraFeed() {
        if (!isCameraFeedRunning) return;
        
        const cameraFeed = document.getElementById('camera-feed');
        const placeholder = document.getElementById('camera-placeholder');
        const btnStart = document.getElementById('btnStartCamera');
        const btnStop = document.getElementById('btnStopCamera');
        
        if (cameraFeed) {
            cameraFeed.src = '';
            cameraFeed.removeAttribute('src');
            cameraFeed.style.display = 'none';
            try {
                cameraFeed.load();
            } catch (e) {}
        }
        
        if (placeholder) {
            placeholder.style.display = 'block';
        }
        
        isCameraFeedRunning = false;
        
        if (btnStart) btnStart.style.display = 'inline-block';
        if (btnStop) btnStop.style.display = 'none';
    }
    
    // Stop camera feed when page is unloaded
    window.addEventListener('beforeunload', function() {
        stopCameraFeed();
    });
    
    window.addEventListener('pagehide', function() {
        stopCameraFeed();
    });
    
    // Make functions globally accessible for onclick handlers
    window.startCameraFeed = startCameraFeed;
    window.stopCameraFeed = stopCameraFeed;
    window.loadCalibration = loadCalibration;
    window.runCalibration = runCalibration;
    window.testCalibration = testCalibration;
    window.moveArmToPosition = moveArmToPosition;
    window.homeArm = homeArm;
    window.clearTestResults = clearTestResults;
    window.resetCalibration = resetCalibration;
    window.clearLastPoint = clearLastPoint;
    window.confirmPoint = confirmPoint;
    window.cancelPoint = cancelPoint;
    window.toggleFullscreen = toggleFullscreen;
    if (typeof refreshCameraList !== 'undefined') {
        window.refreshCameraList = refreshCameraList;
    } else {
        window.refreshCameraList = loadCameraList;  // Fallback alias
    }
    window.refreshCamera = refreshCamera;
    
    // Debug function to check button state (call from console: checkCalibrationButton())
    window.checkCalibrationButton = function() {
        const btn = document.getElementById('calibrate-btn');
        const points = calibrationPoints.length;
        console.log('=== Calibration Button Debug ===');
        console.log('Points:', points);
        console.log('Button disabled:', btn.disabled);
        console.log('Button onclick:', btn.onclick);
        console.log('Button HTML:', btn.outerHTML);
        console.log('Should be enabled:', points >= 4);
        if (points >= 4 && btn.disabled) {
            console.log('âš ï¸  Button should be enabled but is disabled! Fixing...');
            btn.disabled = false;
            console.log('âœ… Button enabled');
        }
        return {
            points: points,
            disabled: btn.disabled,
            shouldBeEnabled: points >= 4
        };
    };
    
    // Load calibration and camera list on page load
    document.addEventListener('DOMContentLoaded', function() {
        loadCalibration();
        loadCameraList();
        
        // Ensure button state is correct after page loads
        setTimeout(function() {
            updatePointsList();
            console.log('Page loaded, calibration points:', calibrationPoints.length);
            console.log('Button state after load:', document.getElementById('calibrate-btn').disabled);
        }, 1500);
        
        // Auto-select USB camera after a short delay
        setTimeout(autoSelectUSBCamera, 1000);
    });
    </script>
{% endblock %}
